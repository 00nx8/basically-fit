var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { E as reactive, n as watch, aw as toRaw } from "./index-DiEwj2lb.js";
class Row {
  /**
   * Can be assigned manually, or generated by `create` or `insert`.
   */
  id;
  /**
   * Retrieve the reactive list of all objects of the type of this subclass.
   * This should not be called on `Row` but on a subclass.
   * The returned value is cached, so the same object will always be returned.
   * @returns The reactive list of objects.
   */
  static all() {
    if (!this._all) {
      const map = /* @__PURE__ */ new Map();
      const all = JSON.parse(localStorage.getItem("tcdb-" + this.name) || "[]").map(
        (rowData) => Object.assign(Object.create(this.prototype), rowData)
      );
      for (const obj of all) {
        this._maxId = Math.max(this._maxId, obj.id);
        map.set(obj.id, obj);
      }
      this._map = reactive(map);
      this._all = reactive(all);
      const syncAll = () => {
        const values = Array.from(this._map.values());
        localStorage.setItem("tcdb-" + this.name, JSON.stringify(values));
        let index = 0;
        for (const rowData of values) {
          this._maxId = Math.max(this._maxId, rowData.id || 0);
          this._all[index++] = rowData;
        }
        if (index < this._all.length) {
          this._all.splice(index, this._all.length - index);
        }
      };
      syncAll();
      setTimeout(() => {
        watch(this._map, syncAll, { deep: true, immediate: true });
      }, 0);
    }
    return this._all;
  }
  /**
   * Reactively retrieve a row from the store by its id. This should
   * not be called on `Row` but on a subclass.
   * @param id The id for the row to retrieve.
   * @returns The row object. Or throws a `RangeError` if it does not exist.
   */
  static get(id) {
    this.all();
    const result = this._map.get(id);
    if (!result) return void 0;
    return result;
  }
  /**
   * Create a new row for a certain type, and optionally add it to the storage. This should
   * not be called on `Row` but on a subclass.
   * @param data An object containing any properties to set for the newly created row.
   * @param insert When `true` (the default), the newly created row is added to the storage.
   * @returns The newly created row, including default values. If `insert` is `true`,
   * it will also include a generated `id` and it will be a reactive object, as it is
   * included in `all`.
   */
  static create(data = {}, insert = true) {
    const obj = Object.assign(new this(), data);
    return insert ? obj.insert() : obj;
  }
  /**
   * Delete this row from the store.
   */
  delete() {
    if (!this.id) throw new Error("delete() called but id was not set");
    const Class = this.constructor;
    Class.all();
    Class._map.delete(this.id);
    console.log("deleted successfully");
  }
  /**
   * If the object has no `id` yet, assign one. Use this `id` to insert it into
   * the `all` object (causing persistence to localStorage).
   * If an `id` is provided, it may overwrite an existing row.
   * @param this The object to save.
   * @returns The reactive version of the object, as it is within `all`.
   */
  insert() {
    const Class = this.constructor;
    Class.all();
    if (!this.id) this.id = ++Class._maxId;
    Class._map.set(this.id, this);
    return Class._map.get(this.id);
  }
  /**
   * Useful to create a temporary working copy that is not included in the store.
   * If desired, the copy can later be persisted by calling `insert` on it.
   * @returns A (non-reactive) deep copy of the object.
   */
  clone() {
    return Object.assign(Object.create(this.constructor.prototype), toRaw(this));
  }
  toString() {
    return `${this.constructor.name}:${this.id}`;
  }
}
// These are populated for each type of Row the first time its
// `all()` is called, based on `rawTables` content.
__publicField(Row, "_map");
__publicField(Row, "_all");
__publicField(Row, "_maxId", 0);
class Exercise extends Row {
  description;
  name;
  voiceNote;
}
class WorkoutPlan extends Row {
  name;
  location = {
    lon: 0,
    lat: 0
  };
  includedWorkouts = [];
  cleanseWorkouts() {
    this.includedWorkouts = this.includedWorkouts.filter((workout) => {
      return workout.exerciseId !== void 0 && Exercise.get(workout.exerciseId) !== void 0;
    });
  }
}
class Workout extends Row {
  reps;
  sets;
  exerciseId;
  exercise = () => {
    return Exercise.create({ ...Exercise.get(this.exerciseId) }, false);
  };
}
export {
  Exercise as E,
  Workout as W,
  WorkoutPlan as a
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxzLWk4VlIza2VOLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9kYi50cyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL21vZGVscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWFjdGl2ZSwgd2F0Y2gsIHRvUmF3IH0gZnJvbSAndnVlJ1xuaW1wb3J0IHR5cGUgeyBSZWFjdGl2ZSB9IGZyb20gJ3Z1ZSdcblxuZXhwb3J0IGNsYXNzIFJvdyB7XG4gIC8vIFRoZXNlIGFyZSBwb3B1bGF0ZWQgZm9yIGVhY2ggdHlwZSBvZiBSb3cgdGhlIGZpcnN0IHRpbWUgaXRzXG4gIC8vIGBhbGwoKWAgaXMgY2FsbGVkLCBiYXNlZCBvbiBgcmF3VGFibGVzYCBjb250ZW50LlxuICBwcml2YXRlIHN0YXRpYyBfbWFwOiBSZWFjdGl2ZTxNYXA8bnVtYmVyLCBSb3c+PlxuICBwcml2YXRlIHN0YXRpYyBfYWxsOiBSZWFjdGl2ZTxSb3dbXT5cbiAgcHJpdmF0ZSBzdGF0aWMgX21heElkID0gMFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgYXNzaWduZWQgbWFudWFsbHksIG9yIGdlbmVyYXRlZCBieSBgY3JlYXRlYCBvciBgaW5zZXJ0YC5cbiAgICovXG4gIHB1YmxpYyBpZDogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSByZWFjdGl2ZSBsaXN0IG9mIGFsbCBvYmplY3RzIG9mIHRoZSB0eXBlIG9mIHRoaXMgc3ViY2xhc3MuXG4gICAqIFRoaXMgc2hvdWxkIG5vdCBiZSBjYWxsZWQgb24gYFJvd2AgYnV0IG9uIGEgc3ViY2xhc3MuXG4gICAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBjYWNoZWQsIHNvIHRoZSBzYW1lIG9iamVjdCB3aWxsIGFsd2F5cyBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybnMgVGhlIHJlYWN0aXZlIGxpc3Qgb2Ygb2JqZWN0cy5cbiAgICovXG4gIHN0YXRpYyBhbGw8UlQgZXh0ZW5kcyB0eXBlb2YgUm93Pih0aGlzOiBSVCk6IFJlYWN0aXZlPEluc3RhbmNlVHlwZTxSVD5bXT4ge1xuICAgIC8vIElmIHdlIGRpZCB0aGlzIGJlZm9yZSBmb3IgdGhpcyB0eXBlIG9mIFJvdywgd2UnbGwganVzdCByZXR1cm5cbiAgICAvLyB0aGUgcmVhY3RpdmUgb2JqZWN0LlxuICAgIGlmICghdGhpcy5fYWxsKSB7XG4gICAgICBjb25zdCBtYXA6IE1hcDxudW1iZXIsIEluc3RhbmNlVHlwZTxSVD4+ID0gbmV3IE1hcCgpXG4gICAgICBjb25zdCBhbGwgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0Y2RiLScgKyB0aGlzLm5hbWUpIHx8ICdbXScpLm1hcChcbiAgICAgICAgKHJvd0RhdGE6IG9iamVjdCkgPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKSwgcm93RGF0YSksXG4gICAgICApXG4gICAgICBmb3IgKGNvbnN0IG9iaiBvZiBhbGwpIHtcbiAgICAgICAgdGhpcy5fbWF4SWQgPSBNYXRoLm1heCh0aGlzLl9tYXhJZCwgb2JqLmlkKVxuICAgICAgICBtYXAuc2V0KG9iai5pZCwgb2JqKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXAgPSByZWFjdGl2ZShtYXApXG4gICAgICB0aGlzLl9hbGwgPSByZWFjdGl2ZShhbGwpXG5cbiAgICAgIGNvbnN0IHN5bmNBbGwgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5fbWFwLnZhbHVlcygpKVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndGNkYi0nICsgdGhpcy5uYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZXMpKVxuICAgICAgICBsZXQgaW5kZXggPSAwXG4gICAgICAgIGZvciAoY29uc3Qgcm93RGF0YSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLl9tYXhJZCA9IE1hdGgubWF4KHRoaXMuX21heElkLCByb3dEYXRhLmlkIHx8IDApXG4gICAgICAgICAgdGhpcy5fYWxsW2luZGV4KytdID0gcm93RGF0YVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuX2FsbC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9hbGwuc3BsaWNlKGluZGV4LCB0aGlzLl9hbGwubGVuZ3RoIC0gaW5kZXgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5bmNBbGwoKVxuICAgICAgLy8gV2UncmUgc3RhcnRpbmcgdGhlIHdhdGNoIGluIGEgc2V0VGltZW91dCwgdG8gcHJldmVudCBhdXRvLWNsZWFudXAgYnlcbiAgICAgIC8vIFZ1ZSBpbiBjYXNlIHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZCBzeW5jaHJvbm91c2x5IHdpdGhpbiBhIGNvbXBvbmVudCBzZXR1cC5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3YXRjaCh0aGlzLl9tYXAsIHN5bmNBbGwsIHsgZGVlcDogdHJ1ZSwgaW1tZWRpYXRlOiB0cnVlIH0pXG4gICAgICB9LCAwKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWxsIGFzIFJlYWN0aXZlPEluc3RhbmNlVHlwZTxSVD5bXT5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFjdGl2ZWx5IHJldHJpZXZlIGEgcm93IGZyb20gdGhlIHN0b3JlIGJ5IGl0cyBpZC4gVGhpcyBzaG91bGRcbiAgICogbm90IGJlIGNhbGxlZCBvbiBgUm93YCBidXQgb24gYSBzdWJjbGFzcy5cbiAgICogQHBhcmFtIGlkIFRoZSBpZCBmb3IgdGhlIHJvdyB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybnMgVGhlIHJvdyBvYmplY3QuIE9yIHRocm93cyBhIGBSYW5nZUVycm9yYCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHN0YXRpYyBnZXQ8UlQgZXh0ZW5kcyB0eXBlb2YgUm93Pih0aGlzOiBSVCwgaWQ6IG51bWJlcik6IEluc3RhbmNlVHlwZTxSVD4gfCB1bmRlZmluZWQge1xuICAgIHRoaXMuYWxsKCkgLy8gTWFrZSBzdXJlIGRhdGEgaXMgaW5pdGlhbGl6ZWQuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbWFwLmdldChpZClcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiByZXN1bHQgYXMgSW5zdGFuY2VUeXBlPFJUPlxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyByb3cgZm9yIGEgY2VydGFpbiB0eXBlLCBhbmQgb3B0aW9uYWxseSBhZGQgaXQgdG8gdGhlIHN0b3JhZ2UuIFRoaXMgc2hvdWxkXG4gICAqIG5vdCBiZSBjYWxsZWQgb24gYFJvd2AgYnV0IG9uIGEgc3ViY2xhc3MuXG4gICAqIEBwYXJhbSBkYXRhIEFuIG9iamVjdCBjb250YWluaW5nIGFueSBwcm9wZXJ0aWVzIHRvIHNldCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgcm93LlxuICAgKiBAcGFyYW0gaW5zZXJ0IFdoZW4gYHRydWVgICh0aGUgZGVmYXVsdCksIHRoZSBuZXdseSBjcmVhdGVkIHJvdyBpcyBhZGRlZCB0byB0aGUgc3RvcmFnZS5cbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgcm93LCBpbmNsdWRpbmcgZGVmYXVsdCB2YWx1ZXMuIElmIGBpbnNlcnRgIGlzIGB0cnVlYCxcbiAgICogaXQgd2lsbCBhbHNvIGluY2x1ZGUgYSBnZW5lcmF0ZWQgYGlkYCBhbmQgaXQgd2lsbCBiZSBhIHJlYWN0aXZlIG9iamVjdCwgYXMgaXQgaXNcbiAgICogaW5jbHVkZWQgaW4gYGFsbGAuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlPFJUIGV4dGVuZHMgdHlwZW9mIFJvdz4oXG4gICAgdGhpczogUlQsXG4gICAgZGF0YTogUGFydGlhbDxJbnN0YW5jZVR5cGU8UlQ+PiA9IHt9LFxuICAgIGluc2VydDogYm9vbGVhbiA9IHRydWUsXG4gICk6IEluc3RhbmNlVHlwZTxSVD4ge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5hc3NpZ24obmV3IHRoaXMoKSwgZGF0YSkgYXMgSW5zdGFuY2VUeXBlPFJUPlxuICAgIHJldHVybiBpbnNlcnQgPyBvYmouaW5zZXJ0KCkgOiBvYmpcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhpcyByb3cgZnJvbSB0aGUgc3RvcmUuXG4gICAqL1xuICBwdWJsaWMgZGVsZXRlKCkge1xuICAgIGlmICghdGhpcy5pZCkgdGhyb3cgbmV3IEVycm9yKCdkZWxldGUoKSBjYWxsZWQgYnV0IGlkIHdhcyBub3Qgc2V0JylcbiAgICBjb25zdCBDbGFzcyA9IHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFJvd1xuICAgIENsYXNzLmFsbCgpIC8vIE1ha2Ugc3VyZSBkYXRhIGlzIGluaXRpYWxpemVkLlxuICAgIENsYXNzLl9tYXAuZGVsZXRlKHRoaXMuaWQpXG4gICAgY29uc29sZS5sb2coJ2RlbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBubyBgaWRgIHlldCwgYXNzaWduIG9uZS4gVXNlIHRoaXMgYGlkYCB0byBpbnNlcnQgaXQgaW50b1xuICAgKiB0aGUgYGFsbGAgb2JqZWN0IChjYXVzaW5nIHBlcnNpc3RlbmNlIHRvIGxvY2FsU3RvcmFnZSkuXG4gICAqIElmIGFuIGBpZGAgaXMgcHJvdmlkZWQsIGl0IG1heSBvdmVyd3JpdGUgYW4gZXhpc3Rpbmcgcm93LlxuICAgKiBAcGFyYW0gdGhpcyBUaGUgb2JqZWN0IHRvIHNhdmUuXG4gICAqIEByZXR1cm5zIFRoZSByZWFjdGl2ZSB2ZXJzaW9uIG9mIHRoZSBvYmplY3QsIGFzIGl0IGlzIHdpdGhpbiBgYWxsYC5cbiAgICovXG4gIGluc2VydDxUIGV4dGVuZHMgUm93Pih0aGlzOiBUKTogVCB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBSb3dcbiAgICBDbGFzcy5hbGwoKSAvLyBNYWtlIHN1cmUgZGF0YSBpcyBpbml0aWFsaXplZC5cbiAgICBpZiAoIXRoaXMuaWQpIHRoaXMuaWQgPSArK0NsYXNzLl9tYXhJZFxuICAgIENsYXNzLl9tYXAuc2V0KHRoaXMuaWQsIHRoaXMpXG4gICAgcmV0dXJuIENsYXNzLl9tYXAuZ2V0KHRoaXMuaWQpIGFzIFRcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VmdWwgdG8gY3JlYXRlIGEgdGVtcG9yYXJ5IHdvcmtpbmcgY29weSB0aGF0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgc3RvcmUuXG4gICAqIElmIGRlc2lyZWQsIHRoZSBjb3B5IGNhbiBsYXRlciBiZSBwZXJzaXN0ZWQgYnkgY2FsbGluZyBgaW5zZXJ0YCBvbiBpdC5cbiAgICogQHJldHVybnMgQSAobm9uLXJlYWN0aXZlKSBkZWVwIGNvcHkgb2YgdGhlIG9iamVjdC5cbiAgICovXG4gIGNsb25lPFQgZXh0ZW5kcyBSb3c+KHRoaXM6IFQpOiBUIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSwgdG9SYXcodGhpcykpXG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX06JHt0aGlzLmlkfWBcbiAgfVxufVxuIiwiaW1wb3J0IHsgUm93IH0gZnJvbSBcIi4vZGJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBWb2ljZU5vdGUge1xuICByZWNvcmREYXRhQmFzZTY0OiBzdHJpbmcsXG4gIG1zRHVyYXRpb246IG51bWJlcixcbiAgbWltZVR5cGU6IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgRXhlcmNpc2UgZXh0ZW5kcyBSb3cge1xuICBwdWJsaWMgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgcHVibGljIG5hbWU/OiBzdHJpbmdcbiAgcHVibGljIHZvaWNlTm90ZT86IFZvaWNlTm90ZVxufVxuXG5leHBvcnQgY2xhc3MgV29ya291dFBsYW4gZXh0ZW5kcyBSb3cge1xuICBwdWJsaWMgbmFtZT86IHN0cmluZ1xuICBwdWJsaWMgbG9jYXRpb246IHtcbiAgICBsb246IG51bWJlcixcbiAgICBsYXQ6IG51bWJlclxuICB9ID0ge1xuICAgIGxvbjogMCxcbiAgICBsYXQ6IDBcbiAgfVxuICBwdWJsaWMgaW5jbHVkZWRXb3Jrb3V0czogV29ya291dFtdID0gW11cblxuICBwdWJsaWMgY2xlYW5zZVdvcmtvdXRzKCkge1xuICAgIHRoaXMuaW5jbHVkZWRXb3Jrb3V0cyA9IHRoaXMuaW5jbHVkZWRXb3Jrb3V0cy5maWx0ZXIod29ya291dCA9PiB7XG4gICAgICByZXR1cm4gd29ya291dC5leGVyY2lzZUlkICE9PSB1bmRlZmluZWQgJiYgRXhlcmNpc2UuZ2V0KHdvcmtvdXQuZXhlcmNpc2VJZCkgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV29ya291dCBleHRlbmRzIFJvdyB7XG4gIHB1YmxpYyByZXBzPzogbnVtYmVyXG4gIHB1YmxpYyBzZXRzPzogbnVtYmVyXG4gIHB1YmxpYyBleGVyY2lzZUlkPzogbnVtYmVyXG5cbiAgcHVibGljIGV4ZXJjaXNlID0gKCkgPT4ge1xuICAgIHJldHVybiBFeGVyY2lzZS5jcmVhdGUoey4uLkV4ZXJjaXNlLmdldCh0aGlzLmV4ZXJjaXNlSWQgYXMgbnVtYmVyKX0sIGZhbHNlKVxuICB9XG5cbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBR08sTUFBTSxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFVUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBUVAsT0FBTyxNQUFtRTtBQUdwRSxRQUFBLENBQUMsS0FBSyxNQUFNO0FBQ1IsWUFBQSwwQkFBeUMsSUFBSTtBQUM3QyxZQUFBLE1BQU0sS0FBSyxNQUFNLGFBQWEsUUFBUSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUksRUFBRTtBQUFBLFFBQ3hFLENBQUMsWUFBb0IsT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLFNBQVMsR0FBRyxPQUFPO0FBQUEsTUFDM0U7QUFDQSxpQkFBVyxPQUFPLEtBQUs7QUFDckIsYUFBSyxT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
